<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Shop Connections</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            /* Deep black background */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff8c00;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
        }

        p {
            margin: 5px 0 0 0;
            font-size: 0.8rem;
            color: #cc5500;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6600;
            font-family: monospace;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>



    <div id="loading" class="loading">INITIALIZING SYSTEM...</div>
    <div id="canvas-container"></div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Configuration
        const config = {
            globeRadius: 100,
            shopCount: 40,
            connectionCount: 30,
            colors: {
                bg: 0x050505,
                globeSurface: 0x111111,
                globeLines: 0x331100,
                node: 0xff6600,      // Orange
                nodeGlow: 0xffaa00,  // Lighter Orange
                line: 0xff4500       // OrangeRed
            },
            rotationSpeed: 0.001
        };

        let scene, camera, renderer, globeGroup;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };

        // Data storage
        const shops = [];

        function init() {
            // Scene Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.colors.bg);
            scene.fog = new THREE.FogExp2(config.colors.bg, 0.002);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 350;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffaa00, 1.5);
            pointLight.position.set(200, 200, 200);
            scene.add(pointLight);

            const backLight = new THREE.PointLight(0xff4500, 0.8);
            backLight.position.set(-200, -100, -200);
            scene.add(backLight);

            // Group to hold all globe elements
            globeGroup = new THREE.Group();
            scene.add(globeGroup);

            createGlobe();
            generateShops();
            createConnections();
            addAtmosphere();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);

            // Mouse/Touch Interaction
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onMouseUp);

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            animate();
        }

        function createGlobe() {
            // 1. Base Sphere (The dark ocean/land mass)
            const geometry = new THREE.IcosahedronGeometry(config.globeRadius, 2); // Low poly look is cool
            // Smooth it out a bit more for a sleek look
            const smoothGeometry = new THREE.SphereGeometry(config.globeRadius, 64, 64);

            const material = new THREE.MeshPhongMaterial({
                color: config.colors.globeSurface,
                emissive: 0x000000,
                specular: 0x111111,
                shininess: 10,
                flatShading: false
            });

            const sphere = new THREE.Mesh(smoothGeometry, material);
            globeGroup.add(sphere);

            // 2. Wireframe / Grid (Technological feel)
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: config.colors.globeLines,
                wireframe: true,
                transparent: true,
                opacity: 0.15
            });
            const wireframeSphere = new THREE.Mesh(new THREE.SphereGeometry(config.globeRadius + 0.2, 24, 24), wireframeMaterial);
            globeGroup.add(wireframeSphere);
        }

        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));

            return new THREE.Vector3(x, y, z);
        }

        function generateShops() {
            const geometry = new THREE.SphereGeometry(1.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: config.colors.node });

            // Add a glow sprite
            const spriteMaterial = new THREE.SpriteMaterial({
                map: createCircleTexture(),
                color: config.colors.nodeGlow,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            for (let i = 0; i < config.shopCount; i++) {
                // Random lat/lon
                // Bias slightly to northern hemisphere where more land/shops usually are, 
                // but keep it global.
                const lat = (Math.random() - 0.4) * 160;
                const lon = (Math.random() - 0.5) * 360;

                const position = latLonToVector3(lat, lon, config.globeRadius);

                // Create the physical dot
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                globeGroup.add(mesh);

                // Create the glow
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(6, 6, 1);
                sprite.position.copy(position.clone().multiplyScalar(1.02)); // Slightly above
                globeGroup.add(sprite);

                shops.push({ mesh, position, lat, lon });
            }
        }

        function createConnections() {
            // Draw curved lines between random pairs
            for (let i = 0; i < config.connectionCount; i++) {
                const startIdx = Math.floor(Math.random() * shops.length);
                let endIdx = Math.floor(Math.random() * shops.length);

                // Avoid self-connection
                while (endIdx === startIdx) {
                    endIdx = Math.floor(Math.random() * shops.length);
                }

                const startPos = shops[startIdx].position;
                const endPos = shops[endIdx].position;
                const distance = startPos.distanceTo(endPos);

                // Create a Bezier curve
                // The height of the arc depends on the distance
                const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
                const arcHeight = distance * 0.5; // Arc goes higher for longer distances

                // Push midpoint out from center to create arc
                midPoint.normalize().multiplyScalar(config.globeRadius + arcHeight);

                const curve = new THREE.QuadraticBezierCurve3(
                    startPos,
                    midPoint,
                    endPos
                );

                const points = curve.getPoints(50);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);

                // Gradient or solid line
                const material = new THREE.LineBasicMaterial({
                    color: config.colors.line,
                    transparent: true,
                    opacity: 0.4,
                    linewidth: 1 // Note: linewidth doesn't always work in WebGL
                });

                const curveObject = new THREE.Line(geometry, material);
                globeGroup.add(curveObject);

                // Add a moving particle along the path
                addMovingPacket(curve);
            }
        }

        function addMovingPacket(curve) {
            const geometry = new THREE.SphereGeometry(0.8, 4, 4);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White hot packet
            const mesh = new THREE.Mesh(geometry, material);
            globeGroup.add(mesh);

            const speed = 0.005 + Math.random() * 0.01;
            let progress = Math.random();

            mesh.userData = {
                curve: curve,
                speed: speed,
                progress: progress
            };

            // Add to animation loop indirectly via a global array if we wanted complex management,
            // but for simplicity, we'll attach an update function to the mesh
            mesh.update = function () {
                this.userData.progress += this.userData.speed;
                if (this.userData.progress > 1) this.userData.progress = 0;

                const point = this.userData.curve.getPoint(this.userData.progress);
                this.position.copy(point);
            };

            // Store in a list to update in animate()
            if (!window.packetMeshes) window.packetMeshes = [];
            window.packetMeshes.push(mesh);
        }

        function addAtmosphere() {
            // Create a glow mesh slightly bigger than globe
            const vertexShader = `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                    gl_FragColor = vec4(1.0, 0.4, 0.0, 1.0) * intensity;
                }
            `;

            const geometry = new THREE.SphereGeometry(config.globeRadius + 10, 64, 64);
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });

            const atmosphere = new THREE.Mesh(geometry, material);
            // Don't add to globeGroup because we want it to stay oriented to camera usually,
            // but for a simple "glow around object", adding to scene is fine.
            // If we add to globeGroup, the glow rotates with the earth which might look weird if shading is view-dependent.
            // But the shader uses view vector. So adding to group is okay.
            globeGroup.add(atmosphere);
        }

        // Helper to make a soft circle texture for sprites
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 160, 0, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 100, 0, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- Interaction Logic ---

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            const rotateSpeed = 0.005;

            // Rotate the group
            globeGroup.rotation.y += deltaMove.x * rotateSpeed;
            globeGroup.rotation.x += deltaMove.y * rotateSpeed;

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onTouchMove(event) {
            event.preventDefault(); // Prevent scrolling
            if (!isDragging || event.touches.length !== 1) return;

            const deltaMove = {
                x: event.touches[0].clientX - previousMousePosition.x,
                y: event.touches[0].clientY - previousMousePosition.y
            };

            const rotateSpeed = 0.005;

            globeGroup.rotation.y += deltaMove.x * rotateSpeed;
            globeGroup.rotation.x += deltaMove.y * rotateSpeed;

            previousMousePosition = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotation (idle)
            if (!isDragging) {
                globeGroup.rotation.y += config.rotationSpeed;
            }

            // Update moving packets
            if (window.packetMeshes) {
                window.packetMeshes.forEach(mesh => mesh.update());
            }

            renderer.render(scene, camera);
        }

        // Initialize everything
        window.onload = init;

    </script>
</body>

</html>